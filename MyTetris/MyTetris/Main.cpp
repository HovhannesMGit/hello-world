#include <iostream>
#include <Windows.h>
#include <ctime>
#include <conio.h>
#include <string>
#include <fstream>
using namespace std;

class Coordinates;
class figure;
void CheckIfFigureIsMoving();

bool gameOver;
const int width = 12;
const int height = 20;
enum eControl { BUTTON_NOT_CLICKED = 0, LEFT, RIGHT, DOWN, ROTATE };
eControl control;
int speed;
int score;
int high_score;
char GameField[height][width];
figure *newFigure;// This will point to every new figure generated by factory()
const int Size = 4;//This is a number which shows how many characters each figure has
Coordinates *temp; //Temporary holder of coordinates
ifstream ifob;//this object gets high_score value from the file
ofstream ofob;//This object sets the new high_score value in the file
string path = "high_score.txt";// This shows the location of high_score file

class Coordinates
{
private:
	int x;
	int y;
	char ch;
public:
	void setX(int x)
	{
		this->x = x;
	}
	void setY(int y)
	{
		this->y = y;
	}
	int getX()
	{
		return x;
	}
	int getY()
	{
		return y;
	}
	void setChar(char ch)
	{
		this->ch = ch;
	}
	char getChar()
	{
		return ch;
	}


};

class figure
{
public:
	
	figure() : startingPointX(4), startingPointY(0), FigCoords(new Coordinates[Size]) {}

	~figure()
	{
		delete[] FigCoords;
	}


    //OO
	//OO and OOOO figures' rotate() function need to be overridden
	virtual void rotate()
	{
		Coordinates *tempFig = new Coordinates[Size];
		for (int i = 0; i < Size; i++)
		{
			tempFig[i].setX(FigCoords[i].getX());
			tempFig[i].setY(FigCoords[i].getY());
			tempFig[i].setChar(FigCoords[i].getChar());
		}

		onlyRotation(tempFig);

		int arr[Size];
		int count = 0;
		for (int i = 0; i < Size; i++)
		{
			for (int j = 0; j < Size; j++)
			{
				if (tempFig[i].getX() == FigCoords[j].getX() && tempFig[i].getY() == FigCoords[j].getY())
				{
					arr[count++] = i;
					break;
				}
			}
		}
		
		int arr1[Size];
		int count1 = 0;
		int c = 0;
		for (int i = 0; i < Size; i++)
		{
			if (i != arr[c])
			{
				arr1[count1++] = i;
			}
			else
			{
				if (c < count - 1) c++;
			}
		}
		


		for (int c = 0; c < count1; c++)
		{
			if (GameField[tempFig[arr1[c]].getY()][tempFig[arr1[c]].getX()] == 'O')
			{
				delete tempFig;
				return;
			}
		}


		onlyRotation(FigCoords);

		outOfBoundaryCheck();
		delete tempFig;
	}

	void leftMovement()
	{
		int leftEl = 0;//Finding one of the leftmost elements
		for (int i = 1; i < Size; i++)
		{
			if (FigCoords[i].getX() < FigCoords[leftEl].getX())
			{
				leftEl = i;
			}
		}

		int arr[Size];//this array will contain all leftmost elements
		int count = 0;//this is the count of leftmost elements
		for (int i = 0; i < Size; i++)
		{
			if (FigCoords[i].getX() == FigCoords[leftEl].getX())
			{
				arr[count++] = i;
			}
		}
		for (int i = 0; i < count; i++)
		{
			if (FigCoords[arr[i]].getX() - 2 < 0 || GameField[FigCoords[arr[i]].getY()][FigCoords[arr[i]].getX() - 1] == 'O')
			{
				return;
			}
		}
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setX(FigCoords[i].getX() - 1);
		}
	}

	void rightMovement()
	{
		int RightEl = 0;//Finding one of the rightmost elements
		for (int i = 1; i < Size; i++)
		{
			if (FigCoords[i].getX() > FigCoords[RightEl].getX())
			{
				RightEl = i;
			}
		}

		int arr[Size];//this array will contain all rightmost elements
		int count = 0;//this is the count of rightmost elements
		for (int i = 0; i < Size; i++)
		{
			if (FigCoords[i].getX() == FigCoords[RightEl].getX())
			{
				arr[count++] = i;
			}
		}


		for (int i = 0; i < count; i++)
		{
			if (FigCoords[arr[i]].getX() + 2 > width - 1 || GameField[FigCoords[arr[i]].getY()][FigCoords[arr[i]].getX() + 1] == 'O')
			{
				return;
			}
		}
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setX(FigCoords[i].getX() + 1);
		}
	}

	void BottomMovement()
	{
		int arr[Size];
		int count = 0;
		for (int i = 0; i < Size; i++)
		{
			int k = i;
			for (int j = 0; j < Size; j++)
			{
				if (i == j)
				{
					continue;
				}
				if (FigCoords[k].getX() == FigCoords[j].getX())
				{
					if (FigCoords[k].getY() < FigCoords[j].getY())
					{
						k = j;
					}
				}
			}
			int l;
			for (l = 0; l < count; l++)
			{
				if (arr[l] == k)
				{
					break;
				}
			}
			if (l == count)
			{
				arr[count++] = k;
			}
		}

		for (int i = 0; i < count; i++)
		{
			if (GameField[FigCoords[arr[i]].getY() + 1][FigCoords[arr[i]].getX()] == 'O' ||
				FigCoords[arr[i]].getY() + 1 == height)
			{
				return;
			}
		}

		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setY(FigCoords[i].getY() + 1);
		}

	}


	Coordinates &operator[](int i)
	{
		return FigCoords[i];
	}

protected:
	Coordinates *FigCoords;
	int startingPointX;
	int startingPointY;
	void outOfBoundaryCheck()//Not letting the figure to go out of boundary
	{
		for (int i = 0; i < Size; i++)
		{
			if (FigCoords[i].getX() < 1)
			{
				for (int j = 0; j < Size; j++)
					FigCoords[j].setX(FigCoords[j].getX() + 1);
			}
			else
			if (FigCoords[i].getX() > width - 2)
			{
				for (int j = 0; j < Size; j++)
					FigCoords[j].setX(FigCoords[j].getX() - 1);
			}
			else
			if (FigCoords[i].getY() == height)
			{
				for (int j = 0; j < Size; j++)
					FigCoords[j].setY(FigCoords[j].getY() - 1);
			}
		}
	}
	void onlyRotation(Coordinates *Temp)
	{
		for (int i = 0; i < Size; i++)
		{
			if (i == 2)
			{
				continue;
			}

			//When both coordinates differ
			if (Temp[i].getX() < Temp[2].getX() && Temp[i].getY() < Temp[2].getY())
			{
				Temp[i].setX(Temp[i].getX() + 2);
			}
			else if (Temp[i].getX() > Temp[2].getX() && Temp[i].getY() < Temp[2].getY())
			{
				Temp[i].setY(Temp[i].getY() + 2);
			}
			else if (Temp[i].getX() < Temp[2].getX() && Temp[i].getY() > Temp[2].getY())
			{
				Temp[i].setY(Temp[i].getY() - 2);
			}
			else if (Temp[i].getX() > Temp[2].getX() && Temp[i].getY() > Temp[2].getY())
			{
				Temp[i].setX(Temp[i].getX() - 2);
			}

			//When one coordinate matches
			if (Temp[i].getX() == Temp[2].getX() && Temp[i].getY() < Temp[2].getY())
			{
				Temp[i].setX(Temp[i].getX() + 1);
				Temp[i].setY(Temp[i].getY() + 1);
			}
			else if (Temp[i].getX() == Temp[2].getX() && Temp[i].getY() > Temp[2].getY())
			{
				Temp[i].setX(Temp[i].getX() - 1);
				Temp[i].setY(Temp[i].getY() - 1);
			}
			else if (Temp[i].getX() < Temp[2].getX() && Temp[i].getY() == Temp[2].getY())
			{
				Temp[i].setX(Temp[i].getX() + 1);
				Temp[i].setY(Temp[i].getY() - 1);
			}
			else if (Temp[i].getX() > Temp[2].getX() && Temp[i].getY() == Temp[2].getY())
			{
				Temp[i].setX(Temp[i].getX() - 1);
				Temp[i].setY(Temp[i].getY() + 1);
			}
		}
	}
};


//O
//OOO
class Figure1 : public figure
{
private:

public:

	Figure1()
	{
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setChar('O');
			FigCoords[i].setX(startingPointX);
			FigCoords[i].setY(startingPointY);
			if (i == 0)
			{
				startingPointY++;
				continue;
			}
			startingPointX++;
		}
	}
};

//*O
//OOO
class Figure3 : public figure
{
private:

public:

	Figure3()
	{
		startingPointX++;
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setChar('O');
			FigCoords[i].setX(startingPointX);
			FigCoords[i].setY(startingPointY);
			if (i == 0)
			{
				startingPointX--;
				startingPointY++;
				continue;
			}
			startingPointX++;
		}
	}
};

//*OO
//OO
class Figure4: public figure
{
public:
	Figure4()
	{
		int startingPointXTemp = startingPointX;
		startingPointX++;
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setChar('O');
			FigCoords[i].setX(startingPointX);
			FigCoords[i].setY(startingPointY);
			if (i == 1)
			{
				startingPointX--;
				startingPointY++;
				continue;
			}
			if (i == 2)
			{
				startingPointX--;
				continue;
			}
			startingPointX++;
		}
	}
};

//OOOO
class Figure5 : public figure
{
public:
	Figure5()
	{
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setX(startingPointX++);
			FigCoords[i].setY(startingPointY);
			FigCoords[i].setChar('O');
		}
	}

	void rotate()
	{
		static bool turn = false;//This determines whether rotation should occur on first or second element of FigCoords

		if (turn == false)
		{
			int tempX = FigCoords[1].getX();
			int tempY = FigCoords[1].getY();
			if (FigCoords[0].getY() == FigCoords[1].getY())//In this line we are checking if figure is in horizontal position or not
			{
				for (int i = 0; i < Size; i++)
				{
					FigCoords[i].setX(tempX);
					FigCoords[i].setY(tempY + i);
				}
			}
			else
			{
				for (int i = 0; i < Size; i++)
				{
					FigCoords[i].setX(tempX - 1 + i);
					FigCoords[i].setY(tempY - 1);
				}
				turn = true;
			}
		}
		else
		{
			int tempX = FigCoords[2].getX();
			int tempY = FigCoords[2].getY();
			if (FigCoords[0].getY() == FigCoords[1].getY())//In this line we are checking if figure is in horizontal position or not
			{
				for (int i = 0; i < Size; i++)
				{
					FigCoords[i].setX(tempX);
					FigCoords[i].setY(tempY + i);
				}
			}
			else
			{
				for (int i = 0; i < Size; i++)
				{
					FigCoords[i].setX(tempX - 2 + i);
					FigCoords[i].setY(tempY - 2);
				}
				turn = false;
			}
		}

		outOfBoundaryCheck();

	}

};

//**O
//OOO
class Figure6 : public figure
{
public:
	Figure6()
	{
		int startingPointXTemp = startingPointX;
		startingPointX += 2;
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setX(startingPointX++);
			FigCoords[i].setY(startingPointY);
			FigCoords[i].setChar('O');
			if (i == 0)
			{
				startingPointY++;
				startingPointX = startingPointXTemp;
			}
		}
	}
};

//OO
//*OO
class Figure7 : public figure
{
public:
	Figure7()
	{
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setX(startingPointX++);
			FigCoords[i].setY(startingPointY);
			FigCoords[i].setChar('O');
			if (i == 1)
			{
				startingPointY++;
				startingPointX--;
			}
		}
	}
};

//OO
//OO
class Figure2 : public figure
{
private:

public:

	Figure2()
	{
		int startingPointXTemp = startingPointX;
		for (int i = 0; i < Size; i++)
		{
			FigCoords[i].setChar('O');
			FigCoords[i].setX(startingPointX);
			FigCoords[i].setY(startingPointY);
			if (i == 1)
			{
				startingPointX = startingPointXTemp;
				startingPointY++;
				continue;
			}
			startingPointX++;
		}
	}

	void rotate()
	{
		//This figure cannot be rotated
	}
};



figure *factory()//Generating new figure
{
	switch (rand() % 7)
	{
	case 0: return new Figure1();
	case 1: return new Figure2();
	case 2: return new Figure3();
	case 3: return new Figure4();
	case 4: return new Figure5();
	case 5: return new Figure6();
	case 6: return new Figure7();
	}
}


void setup()
{
	for (int i = 0; i < height; i++)
	{
		for (int j = 0; j < width; j++)
		{
			if (j == 0 || j == width - 1) GameField[i][j] = '#';
			else GameField[i][j] = ' ';
		}
	}


	ifob.open(path);
	if (ifob.is_open())
	{
		ifob >> high_score;
		ifob.close();
	}
	else
	{
		ofob.open(path);
		high_score = 0;
	}


	gameOver = false;
	speed = 100;
	score = 0;
	newFigure = nullptr;
	temp = new Coordinates[Size];
}


void draw()
{
	system("cls");
	for (int col = 0; col < width; col++)
	{
		cout << "#";
	}
	cout << endl;



	for (int i = 0; i < height; i++)
	{
		for (int j = 0; j < width; j++)
		{
			cout << GameField[i][j];
		}
		cout << endl;
	}


	for (int col = 0; col < width; col++)
	{
		cout << '#';
	}
	cout << endl;

	cout << "Score = " << score << "\t\t" << "High Score = " << high_score;
}


void clearFigureTrail()
{
	for (int i = 0; i < Size; i++)
	{
		GameField[temp[i].getY()][temp[i].getX()] = ' ';
	}
}
void clearRow()//This function clears all those rows that are full
{
	int rows[height];//This array contains all rows that are full
	int count = 0;//This is the count of full rows

	//Finding all rows that are full
	for (int row = 0; row < height; row++)
	{
		int col;
		for (col = 1; col < width - 1; col++)
		{
			if (GameField[row][col] != 'O')
			{
				break;
			}
		}
		if (col == width - 1)
		{
			rows[count++] = row;
		}
	}

	//Deleting all rows that are full
	for (int fullRow = 0; fullRow < count; fullRow++)
	{
		for (int col = 1; col < width - 1; col++)
		{
			GameField[rows[fullRow]][col] = ' ';
		}
	}

	score += count;
	if (score > high_score)
	{
		high_score = score;
	}

	for (int emptyRow = 0; emptyRow < count; emptyRow++)
	{
		for (int row = rows[emptyRow]; row > 0; row--)
		{
			for (int col = 1; col < width - 1; col++)
			{
				GameField[row][col] = GameField[row - 1][col];
				GameField[row - 1][col] = ' ';
			}
		}
	}
	

}

void logic()            
{
	if (newFigure == nullptr)
	{
		newFigure = factory();
	}

	//Temporarily inserting coordinates of newFigure into temp 
	for (int i = 0; i < Size; i++)
	{
		temp[i].setX((*newFigure)[i].getX());
		temp[i].setY((*newFigure)[i].getY());
		temp[i].setChar((*newFigure)[i].getChar());
	}

	switch (control)
	{
	case LEFT: newFigure->leftMovement();
		break;
	case RIGHT: newFigure->rightMovement();
		break;
	case ROTATE: newFigure->rotate();
		break;
	case DOWN: speed = 1;
		break;
	}

	newFigure->BottomMovement();
	clearFigureTrail();
	for (int i = 0; i < Size; i++)
	{
		GameField[(*newFigure)[i].getY()][(*newFigure)[i].getX()] = 'O';
	}
	
	CheckIfFigureIsMoving();
	
}


void CheckIfFigureIsMoving()
{
	for (int i = 0; i < Size; i++)
	{
		if (temp[i].getX() != (*newFigure)[i].getX() || temp[i].getY() != (*newFigure)[i].getY())
		{
			return;
		}
	}
	if ((*newFigure)[0].getX() == 4 && (*newFigure)[0].getY() == 0)
	{
		gameOver = true;
	}
	delete newFigure;
	newFigure = nullptr;
	clearRow();
}



void input()
{
	if (_kbhit())
	{
		speed = 100;
		switch (_getwch())
		{
		case 'a': control = LEFT;
			break;
		case 'd': control = RIGHT;
			break;
		case 'w': control = ROTATE;
			break;
		case 's': control = DOWN;
			break;
		case 'x': gameOver = true;
			break;
		}
	}
	else 
	{
		speed = 200;
		control = BUTTON_NOT_CLICKED;
	}
	
}

int main()
{
	
	srand(time(NULL));
	setup();
	do
	{
		input();
		logic();            
		draw();
		Sleep(speed);
	} while (!gameOver);

	cout << "\n\n\n\t\t\t\tGame Over\n";

	if (!ofob.is_open()) ofob.open(path);
	ofob << high_score;
	ofob.close();
}